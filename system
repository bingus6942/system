exp 2 

ping google.com (Used to test the reachability of a host and measure the round-trip time for messages sent from
the originating host to a destination computer.)
traceroute google.com (Traces the route that packets take to a network host.)
nslookup google.com (Queries Internet domain name servers to find IP addresses associated with a domain name.)
netstat -tuln (Displays network connections, routing tables, interface statistics, masquerade connections, and
multicast memberships.)
arp -a (Displays and modifies the IP-to-Physical address translation tables used by the Address Resolution
Protocol (ARP))
rarp -a (Reverse Address Resolution Protocol, used to request an IP address from a gateway server based
on the MAC address. Often replaced by DHCP.)
ip addr show (To show IP addresses:)
ip route show (To display routing table:)
ifconfig (Configures network interfaces.)
ifconfig eth0 up 
dig google.com (DNS lookup utility, provides more detailed information than `nslookup`.)
route -n (To display the routing table:)

exp 3 ???

exp 4

INSATALLATION OF WIRE SHARK USING TERMINAL -->
    1. sudo add-apt-repository ppa:wireshark-dev/stable
    2. sudo apt-get update
    3. sudo apt-get install wireshark
    4. sudo wireshark

COMMANDS TO RUN IN WIRE SHARK
    Run all the commands on the titlebar
    1. tcp
    2. udp.port == 443 
    3. udp 
    4. tcp.port == 443 
    5. eth 
    6. ip addr  == 192.168.3.10
    7. dns 
    8. arp 
    9. ip 
    10. Promiscuous mode 

exp 5

set ns [new Simulator]
$ns color 1 Green
$ns color 2 Yellow
set nf [open out.nam w]
$ns namtrace-all $nf

proc finish {} {
global ns nf
$ns flush-trace
close $nf
exec nam out.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
$ns duplex-link $n0 $n2 2Mb 10ms DropTail
$ns duplex-link $n1 $n2 2Mb 10ms DropTail
$ns duplex-link $n2 $n3 1.7Mb 20ms DropTail
$ns duplex-link $n3 $n4 2Mb 10ms DropTail
$ns duplex-link $n3 $n5 2Mb 10ms DropTail

$ns duplex-link-op $n0 $n2 orient right-down
$ns duplex-link-op $n1 $n2 orient right-up
$ns duplex-link-op $n2 $n3 orient right
$ns duplex-link-op $n3 $n4 orient right-down
$ns duplex-link-op $n3 $n5 orient right-up

#TCP
set tcp [new Agent/TCP]
$tcp set class_ 2
$ns attach-agent $n0 $tcp

set sink [new Agent/TCPSink]
$ns attach-agent $n5 $sink
$ns connect $tcp $sink
$tcp set fid_ 1
# FTP over TCP
set ftp [new Application/FTP]
$ftp attach-agent $tcp
$ftp set type_ FTP
#UDP
set udp [new Agent/UDP]
$ns attach-agent $n1 $udp
set null [new Agent/Null]
$ns attach-agent $n4 $null
$ns connect $udp $null
$udp set fid_ 2
#CBR over UDP
set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp
$cbr set packet_size_ 1000
$cbr set rate_ 1mb
$cbr set random_ false
$ns at 0.1 "$cbr start"
$ns at 1.0 "$ftp start"
$ns at 4.0 "$ftp stop"
$ns at 4.5 "$cbr stop"

# Call the finish procedure after 5 seconds of simulation time
$ns at 5.0 "finish"

puts "CBR packet size = [$cbr set packet_size_]"
puts "CBR interval = [$cbr set interval_]"
$ns run

exp 6

# Define the number of nodes
set num_nodes 2
# Create the simulator object
set ns [new Simulator]
# Open the NAM trace file
set nf [open out.nam w]
$ns namtrace-all $nf
# Define a finish procedure
proc finish {} {
global ns nf
$ns flush-trace
close $nf
exec nam out.nam &
exit 0
}
# Create nodes
set node1 [$ns node]
set node2 [$ns node]
# Create duplex link between nodes
$ns duplex-link $node1 $node2 1Mb 10ms DropTail
# Define sliding window parameters
set window_size 4
set num_packets 10
set packet_size 500
# TCP Setup for sliding window (Go-Back-N)
set tcp [new Agent/TCP]
$tcp set window_ $window_size
$ns attach-agent $node1 $tcp
# TCP Sink at the receiver node
set sink [new Agent/TCPSink]
$ns attach-agent $node2 $sink
$ns connect $tcp $sink
# FTP Application over TCP to send data
set ftp [new Application/FTP]

$ftp attach-agent $tcp
$ftp set packetSize_ $packet_size
$ftp set maxpkts_ $num_packets
# Simulation starting point
$ns at 0.5 "$ftp start"
# Set simulation end time
$ns at 10.0 "finish"
# Run the simulation
$ns run

exp 7 ???



exp 8

TCP server : 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
	int server_fd, client_fd;
	struct sockaddr_in server_addr;
	char buffer[BUFFER_SIZE];

	if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
    	perror("Socket creation failed");
    	exit(EXIT_FAILURE);
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port = htons(PORT);

	if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
    	perror("Bind failed");
    	close(server_fd);
    	exit(EXIT_FAILURE);
	}

	if (listen(server_fd, 3) < 0) {
    	perror("Listen failed");
    	close(server_fd);
    	exit(EXIT_FAILURE);
	}
	printf("Server listening on port %d\n", PORT);

	if ((client_fd = accept(server_fd, NULL, NULL)) < 0) {
    	perror("Accept failed");
    	close(server_fd);
    	exit(EXIT_FAILURE);
	}

	int bytes_read = read(client_fd, buffer, BUFFER_SIZE);
	if (bytes_read < 0) {
    	perror("Read failed");
    	close(client_fd);
    	close(server_fd);
    	exit(EXIT_FAILURE);
	}
	buffer[bytes_read] = '\0';
	printf("Received from client: %s\n", buffer);

	const char *response = "Hello\n";
	write(client_fd, response, strlen(response));

	close(client_fd);
	close(server_fd);
	return 0;
}

TCP client : 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
	int sock;
	struct sockaddr_in server_addr;
	char *message = "Aditya Saharkar from TCP Client!";
	char buffer[BUFFER_SIZE];

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    	perror("Socket creation error");
    	return -1;
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(PORT);
    
	if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
    	perror("Invalid address / Address not supported");
    	return -1;
	}

	if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
    	perror("Connection failed");
    	return -1;
	}

	write(sock, message, strlen(message));
	int bytes_read = read(sock, buffer, BUFFER_SIZE);
	buffer[bytes_read] = '\0';
	printf("Response from server: %s", buffer);

	close(sock);
	return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
	int sock;
	struct sockaddr_in server_addr, client_addr;
	char buffer[BUFFER_SIZE];
	socklen_t addr_len = sizeof(client_addr);

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    	perror("Socket creation failed");
    	exit(EXIT_FAILURE);
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = INADDR_ANY;
	server_addr.sin_port = htons(PORT);

	if (bind(sock, (const struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
    	perror("Bind failed");
    	close(sock);
    	exit(EXIT_FAILURE);
	}

	printf("UDP Server listening on port %d\n", PORT);

	int n = recvfrom(sock, buffer, BUFFER_SIZE, MSG_WAITALL, (struct sockaddr*)&client_addr, &addr_len);
	buffer[n] = '\0';
	printf("Received from client: %s\n", buffer);

	const char *response = "Hello from UDP Server!";
	sendto(sock, response, strlen(response), MSG_CONFIRM, (const struct sockaddr*)&client_addr, addr_len);

	close(sock);
	return 0;
}

UDP client : 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
	int sock;
	struct sockaddr_in server_addr;
	char *message = "Aditya Saharkar from UDP Client!";
	char buffer[BUFFER_SIZE];

	if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    	perror("Socket creation error");
    	return -1;
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(PORT);

	if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
    	perror("Invalid address / Address not supported");
    	return -1;
	}

	sendto(sock, message, strlen(message), MSG_CONFIRM, (const struct sockaddr*)&server_addr, sizeof(server_addr));

	socklen_t addr_len;
	int n = recvfrom(sock, buffer, BUFFER_SIZE, MSG_WAITALL, (struct sockaddr*)&server_addr, &addr_len);
	buffer[n] = '\0';
	printf("Response from server: %s\n", buffer);

	close(sock);
	return 0;
}

exp 9 ???

exp 10???

  
